{"ts":1372160149189,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"# CHAPTER 10\n\n## Sorting via recursion\n\n# So, we want to sort an array of words, and we know how to find out which of two words comes first\n# in the dictionary (using <).\n# The easiest way to do this is to keep two more lists around: one will be our list of already-sorted words,\n#  and the other will be our list of still-unsorted words.\n# We\\’ll take our list of words, find the “smallest” word\n# (that is, the word that would come first in the dictionary), and stick it at the end of the already-sorted list.\n# All of the other words go into the still-unsorted list.\n# Then you do the same thing again but using the still-unsorted list instead of your original list:\n#  > Find the smallest word, move it to the sorted list, and move the rest to the unsorted list.\n#  > Keep going until your still-unsorted list is empty.\n# With the recursion, you might need a wrapper method, a tiny method that wraps up another method.\n\ndef sort arr                          # This wraps rec_sort so that we don't have to always supply [] as a destination array\n                                      # for the sorted list. It saves remembering to pass the empty array.\n  rec_sort arr, []\nend\n\ndef rec_sort submitted, sorted        # The parameter arrays correspond to [arr] and [] in the wrapper method, correct?\n  if submitted.length <= 0            # If [submitted] is empty, then all words have been sorted. Return [sorted] list\n    return sorted                     # and stop.\n  end\n\n  smallest = submitted.pop            # Remove 'can' from [submitted] and assign it to [smallest]\n  unsorted = []                       # This is the temporary array to dump the still-unsorted words\n                                      # each time the method runs, correct? And it empties each time? If it's emptied, don't we\n                                      # lose the unsorted words? Or is the [submitted] array retained throughout until it's also\n                                      # empty?\n\n  submitted.each do |tested_word|     # For each word in the [submitted] array:\n    if tested_word < smallest         # If 'bat' is smaller than 'can' ([smallest])\n      unsorted.push smallest          # add 'can' to the end of [unsorted]\n      smallest = tested_word          # and change [smallest] to 'bat'.\n                                      # (So this is what cycles through [submitted] and tests each word\n                                      # until it finds the smallest word in the array. Then it pushes that word to [sorted]\n                                      # and starts over, looking for the next smallest word.)\n    else\n      unsorted.push tested_word       # Otherwise, if [tested_word] is bigger than [smallest],\n                                      # add [tested_word] to the end of [unsorted], because we know it isn't the\n                                      # smallest.\n    end\n  end                                 # What is this ending?\n\n  sorted.push smallest                # Add 'bat' to [sorted], because now we know it's the smallest.\n  rec_sort unsorted, sorted           # Call rec_sort again, but this time using [unsorted] rather than [submitted].\n                                      # [submitted] is only used the first time to establish the original list. After that,\n                                      # the method continues to add words to either [unsorted] or [sorted] until\n                                      # [unsorted] is empty.\nend\n\nputs(sort(['bat', 'feel', 'singing', 'like', 'a', 'can']))\n\n"]],"start1":0,"start2":0,"length1":0,"length2":3532}]],"length":3532}
