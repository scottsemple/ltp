{"ts":1372160146194,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1372428277729,"patch":[[{"diffs":[[1,"# CHAPTER 10\n\n## Shuffling via recursion\n\ndef shuffle arr\n  rec_shuffle arr, []\nend\n\n# Process:\n# Establish the base case for when the shuffle would stop.\n# Then the recursive case which would include three arrays:\n# > [submitted] for the initial list;\n# > [shuffled] for the shuffled list; and\n# > [unshuffled] for the unshuffled list.\n\n# # Randomly select a word from [submitted] and move it to [shuffled];\n# # Move the remaining words from [submitted] into [unshuffled];\n# # Randomly select a word from [unshuffled] and move it into [shuffled];\n# # Repeat the last step until the base case is achieved.\n\ndef rec_shuffle submitted, shuffled   # Base case, then recursive case\n  # First, the base case:\n  if submitted.length <= 0            # If [submitted] is empty, then all words have been sorted. Return [sorted] list\n    return shuffled                     # and stop. Or does is each instance of [submitted] replaced in the method by [unsorted]\n                                      # after the first run-through?\n  end\n\n  smallest = submitted.pop            # Remove 'can' from [submitted] and assign it to [smallest]\n  unshuffled = []                       # This is the temporary array to dump the still-unsorted words\n                                      # each time the method runs, correct? And it empties each time? If it's emptied, don't we\n                                      # lose the unsorted words? Or is the [submitted] array retained throughout until it's also\n                                      # empty?\n\n  submitted.each do |tested_word|     # For each word in the [submitted] array:\n    if tested_word < smallest         # SAMPLE: If 'bat' is smaller than 'can' ([smallest])\n      unshuffled.push smallest          # add 'can' to the end of [unsorted]\n      smallest = tested_word          # and change [smallest] to 'bat'.\n                                      # (So this is what cycles through [submitted] and tests each word\n                                      # until it finds the smallest word in the array. Then it pushes that word to [sorted]\n                                      # and starts over, looking for the next smallest word.)\n    else\n      unshuffled.push tested_word       # Otherwise, if [tested_word] is bigger than [smallest],\n                                      # add [tested_word] to the end of [unsorted], because we know it isn't the\n                                      # smallest.\n    end\n  end                                 # What is this ending?\n\n  shuffled.push smallest                # Add 'bat' to [sorted], because now we know it's the smallest.\n  rec_shuffle unshuffled, shuffled           # Call rec_sort again, but this time using [unsorted] rather than [submitted].\n                                      # [submitted] is only used the first time to establish the original list. After that,\n                                      # the method continues to add words to either [unsorted] or [sorted] until\n                                      # [unsorted] is empty.\nend\n\nputs(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]))\n\n"]],"start1":0,"start2":0,"length1":0,"length2":3091}]],"length":3091,"saved":false}
{"ts":1372428971318,"patch":[[{"diffs":[[0,"bmitted]"],[-1," and move it"],[1,";\n# # Move the selection"],[0," to [shu"]],"start1":373,"start2":373,"length1":28,"length2":40},{"diffs":[[0,"fled"],[-1,"   # Base case, then recursive case"],[0,"\n  #"]],"start1":650,"start2":650,"length1":43,"length2":8},{"diffs":[[0," [submitted]"],[1," (or [unshuffled])"],[0," is empty, t"]],"start1":723,"start2":723,"length1":24,"length2":42},{"diffs":[[0,"en s"],[-1,"orted. Return [sorted] list"],[1,"huffled."],[0,"\n   "]],"start1":786,"start2":786,"length1":35,"length2":16},{"diffs":[[0,"    "],[-1,"  # and stop. Or does is each instance of [submitted] replaced in the method by [unsorted]\n                                      # after the first run-through?\n  end\n\n  smallest = submitted.pop            # Remove 'can' from [submitted] and assign it to [smallest]\n  unshuffled = []                       # This is the temporary array to dump the still-unsorted words\n                                      # each time the method runs, correct? And it empties each time? If it's emptied, don't we\n                                      # lose the unsorted words? Or is the [submitted] array retained throughout until it's also\n                                      # empty?"],[1,"# Return [shuffled] and stop.\n  end\n\n  index = rand(submitted.length)\n  selection = submitted[index]\n  unshuffled = []\n  \n  "],[0,"\n\n  "]],"start1":833,"start2":833,"length1":679,"length2":132}]],"length":2520,"saved":false}
{"ts":1372429442198,"patch":[[{"diffs":[[0,"lect"],[-1,"ion = submitted[index]\n  unshuffled = []\n  \n  \n\n  submitted.each do |tested_word|     # For each word in the [submitted] array:\n    if tested_word < smallest         # SAMPLE: If 'bat' is smaller than 'can' ([smallest])\n      unshuffled.push smallest          # add 'can' to the end of [unsorted]\n      smallest = tested_word          # and change [smallest] to 'bat'.\n                                      # (So this is what cycles through [submitted] and tests each word\n                                      # until it finds the smallest word in the array. Then it pushes that word to [sorted]\n                                      # and starts over, looking for the next smallest word.)\n    else\n      unshuffled.push tested_word       # Otherwise, if [tested_word] is bigger than [smallest],\n                                      # add [tested_word] to the end of [unsorted], because we know it isn't the\n                                      # smallest.\n    end"],[1,"ed_word = submitted[index]\n  unshuffled = []\n"],[0,"\n  e"]],"start1":911,"start2":911,"length1":975,"length2":53}]],"length":1598,"saved":false}
{"ts":1372429679251,"patch":[[{"diffs":[[0,"\n\n  "],[-1,"end                                 # What is this ending?\n\n  shuffled.push smallest                # Add 'bat' to [sorted], because now we know it's the smallest.\n  rec_shuffle unshuffled, shuffled           # Call rec_sort again, but this time using [unsorted] rather than [submitted].\n                                      # [submitted] is only used the first time to establish the original list. After that,\n                                      # the method continues to add words to either [unsorted] or [sorted] until\n                                      # [unsorted] is empty."],[1,"shuffled.push selected_word\n  submitted.delete_at(index)\n\n  rec_shuffle unshuffled, shuffled"],[0,"\nend"]],"start1":959,"start2":959,"length1":593,"length2":100}]],"length":1105,"saved":false}
{"ts":1372429804111,"patch":[[{"diffs":[[0,"hen all "],[-1,"word"],[1,"item"],[0,"s have b"]],"start1":765,"start2":765,"length1":20,"length2":20},{"diffs":[[0,".length)"],[1,"      # Create a random index value."],[0,"\n  selec"]],"start1":898,"start2":898,"length1":16,"length2":52},{"diffs":[[0,"  select"],[-1,"ed_word"],[1,"ion"],[0," = submi"]],"start1":943,"start2":943,"length1":23,"length2":19},{"diffs":[[0,"d[index]"],[1,"    # Randomly select an item."],[0,"\n  unshu"]],"start1":965,"start2":965,"length1":16,"length2":46},{"diffs":[[0,"lect"],[-1,"ed_word"],[1,"ion"],[0,"\n  s"]],"start1":1041,"start2":1041,"length1":15,"length2":11}]],"length":1163,"saved":false}
{"ts":1372429848109,"patch":[[{"diffs":[[0,"d[index]"],[1,"    "],[0,"    # Ra"]],"start1":965,"start2":965,"length1":16,"length2":20},{"diffs":[[0,"led = []"],[1,"                     # The empty array for unshuffled items."],[0,"\n\n  shuf"]],"start1":1017,"start2":1017,"length1":16,"length2":76},{"diffs":[[0,"(index)\n"],[1,"  \n  "],[0,"\n  rec_s"]],"start1":1134,"start2":1134,"length1":16,"length2":21}]],"length":1232,"saved":false}
{"ts":1372430097747,"patch":[[{"diffs":[[0,"ush "],[-1,"selection\n  "],[0,"subm"]],"start1":1099,"start2":1099,"length1":20,"length2":8}]],"length":1220,"saved":false}
{"ts":1372430247816,"patch":[[{"diffs":[[0,"        "],[1,"      "],[0,"# If [su"]],"start1":711,"start2":711,"length1":16,"length2":22},{"diffs":[[0,"        "],[1,"      "],[0,"# Return"]],"start1":835,"start2":835,"length1":16,"length2":22},{"diffs":[[0,".length)"],[1,"      "],[0,"      # "]],"start1":910,"start2":910,"length1":16,"length2":22},{"diffs":[[0,"\n  s"],[-1,"election = submitted[index]        # Randomly select an item.\n  unshuffled = []                     # The empty array for unshuffled items.\n\n  shuffled.push submitted.delete_at(index)\n  \n"],[1,"huffled.push submitted.delete_at(index)  # Randomly select an item from [submitted] (or [unshuffled]), delete it and\n                                            # push it to [shuffled]."],[0,"  \n "]],"start1":960,"start2":960,"length1":195,"length2":193}]],"length":1236,"saved":false}
{"ts":1372430291837,"patch":[[{"diffs":[[0,"shuffle "],[-1,"submitt"],[1,"unshuffl"],[0,"ed, shuf"]],"start1":627,"start2":627,"length1":23,"length2":24},{"diffs":[[0,"e:\n  if "],[-1,"submitt"],[1,"unshuffl"],[0,"ed.lengt"]],"start1":679,"start2":679,"length1":23,"length2":24}]],"length":1238,"saved":false}
{"ts":1372430306010,"patch":[[{"diffs":[[0,"ed.push "],[-1,"submitt"],[1,"unshuffl"],[0,"ed.delet"]],"start1":971,"start2":971,"length1":23,"length2":24}]],"length":1239,"saved":false}
{"ts":1372430322579,"patch":[[{"diffs":[[0," = rand("],[-1,"submitt"],[1,"unshuffl"],[0,"ed.lengt"]],"start1":895,"start2":895,"length1":23,"length2":24},{"diffs":[[0," it and\n"],[1," "],[0,"        "]],"start1":1077,"start2":1077,"length1":16,"length2":17}]],"length":1241,"saved":false}
{"ts":1372430487028,"patch":[[{"diffs":[[0,"ocess:\n#"],[1," #"],[0," Establi"]],"start1":89,"start2":89,"length1":16,"length2":18},{"diffs":[[0,"stop"],[-1,".\n# Then the recursive case which would include three arrays:\n# > [submitted] for the initial list;\n# > [shuffled] for the shuffled list; and\n# > [unshuffled] for the unshuffled list.\n\n# # Randomly select a word from [submitted];\n# # Move the selection to [shuffled];\n# # Move the remaining words from [submitted] into [unshuffled];\n# # Randomly select a word from [unshuffled] and move it in"],[1,";\n# # Randomly select a word from [unshuffled];\n# # Move the selection "],[0,"to ["]],"start1":151,"start2":151,"length1":400,"length2":79},{"diffs":[[0,"eat "],[-1,"the last step "],[0,"unti"]],"start1":248,"start2":248,"length1":22,"length2":8},{"diffs":[[0,"        "],[-1," "],[0,"# If [su"]],"start1":385,"start2":385,"length1":17,"length2":16},{"diffs":[[0,".length)"],[-1," "],[0,"        "]],"start1":579,"start2":579,"length1":17,"length2":16},{"diffs":[[0,"t(index)"],[-1," "],[0," # Rando"]],"start1":664,"start2":664,"length1":17,"length2":16},{"diffs":[[0," it and\n"],[-1," "],[0,"        "]],"start1":741,"start2":741,"length1":17,"length2":16}]],"length":904,"saved":false}
